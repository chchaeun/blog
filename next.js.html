<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><title>개발새발</title><link rel="apple-touch-icon" sizes="180x180" href="/blog/assets/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/blog/assets/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/blog/assets/favicon-16x16.png"/><link rel="manifest" href="/blog/assets/site.webmanifest"/><meta name="msapplication-TileColor" content="#da532c"/><meta name="theme-color" content="#ffffff"/><link rel="icon" type="image/x-icon" href="/blog/assets/favicon.ico"/><meta name="next-head-count" content="10"/><link rel="preload" href="/blog/_next/static/css/744ee1eb5e37bc8a.css" as="style"/><link rel="stylesheet" href="/blog/_next/static/css/744ee1eb5e37bc8a.css" data-n-g=""/><link rel="preload" href="/blog/_next/static/css/b9ebd73734f4ce37.css" as="style"/><link rel="stylesheet" href="/blog/_next/static/css/b9ebd73734f4ce37.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/blog/_next/static/chunks/polyfills-0d1b80a048d4787e.js"></script><script src="/blog/_next/static/chunks/webpack-2a0e07a68ff4e373.js" defer=""></script><script src="/blog/_next/static/chunks/framework-ae4f43955bfa5ddc.js" defer=""></script><script src="/blog/_next/static/chunks/main-03bd4db74e21b6d3.js" defer=""></script><script src="/blog/_next/static/chunks/pages/_app-e12edf3ac80965c0.js" defer=""></script><script src="/blog/_next/static/chunks/849-a99de2bc171c3f7a.js" defer=""></script><script src="/blog/_next/static/chunks/pages/%5Bid%5D-a032d178f2e71901.js" defer=""></script><script src="/blog/_next/static/OL6IxY-eToHWPnPapaxI-/_buildManifest.js" defer=""></script><script src="/blog/_next/static/OL6IxY-eToHWPnPapaxI-/_ssgManifest.js" defer=""></script></head><body><div id="__next"><nav class="flex bg-white sticky top-0 left-0 z-50 justify-between items-center border-b-2 border-gray-100 py-3 md:justify-start md:space-x-10 px-10 sm:px-5 dark:bg-[#0d1117] dark:text-[#c9d1d9] dark:border-gray-600"><div class="flex justify-start"><div class="flex items-center gap-2 cursor-pointer"><span style="box-sizing:border-box;display:inline-block;overflow:hidden;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;position:relative;max-width:100%"><span style="box-sizing:border-box;display:block;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;max-width:100%"><img style="display:block;max-width:100%;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0" alt="" aria-hidden="true" src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%2740%27%20height=%2740%27/%3e"/></span><img alt="블로그 아이콘" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="intrinsic" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%"/><noscript><img alt="블로그 아이콘" srcSet="https://velog.velcdn.com/images/chchaeun/profile/01725b7d-94eb-4baa-a83d-753405c4d646/social.png?imwidth=48 1x, https://velog.velcdn.com/images/chchaeun/profile/01725b7d-94eb-4baa-a83d-753405c4d646/social.png?imwidth=96 2x" src="https://velog.velcdn.com/images/chchaeun/profile/01725b7d-94eb-4baa-a83d-753405c4d646/social.png?imwidth=96" decoding="async" data-nimg="intrinsic" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%" loading="lazy"/></noscript></span><h1 class="text-lg ">개발새발</h1></div></div><div class="flex justify-between gap-10 sm:hidden"><button class="font-light hover:text-indigo-300 text-base">Home</button><button class="font-light hover:text-indigo-300 text-base">Category</button><button class="font-light hover:text-indigo-300 text-base">About</button></div><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 512 512" class="lg:hidden" height="25" width="25" xmlns="http://www.w3.org/2000/svg"><path d="M32 96v64h448V96H32zm0 128v64h448v-64H32zm0 128v64h448v-64H32z"></path></svg></nav><main class="dark:bg-[#0d1117]"><div class="flex flex-col w-3/5 sm:w-5/6 m-auto pt-20 pb-20 gap-10 dark:bg-[#0d1117] dark:text-[#c9d1d9]"><ul id="scroll-spy" class="sm:hidden p-10 fixed top-50 right-0 h-full w-1/5 text-gray-500 dark:text-[#c9d1d9]"></ul><div class="text-5xl font-bold">next.js</div><div class="flex flex-col gap-2"><div class="text-base text-gray-600 dark:text-gray-300">2022-07-12 10:00</div><div class="flex gap-2 dark:text-black flex-wrap sm:m-0"><span class="p-1 pl-3 pr-3 rounded-md bg-indigo-100 hover:bg-indigo-200 cursor-pointer transition ease-in-out duration-200 text-sm">Next.js</span><span class="p-1 pl-3 pr-3 rounded-md bg-indigo-100 hover:bg-indigo-200 cursor-pointer transition ease-in-out duration-200 text-sm">SSR</span><span class="p-1 pl-3 pr-3 rounded-md bg-indigo-100 hover:bg-indigo-200 cursor-pointer transition ease-in-out duration-200 text-sm">SSG</span><span class="p-1 pl-3 pr-3 rounded-md bg-indigo-100 hover:bg-indigo-200 cursor-pointer transition ease-in-out duration-200 text-sm">frontend</span><span class="p-1 pl-3 pr-3 rounded-md bg-indigo-100 hover:bg-indigo-200 cursor-pointer transition ease-in-out duration-200 text-sm">react</span></div></div><div class="markdown-body" style="font-size:17px"><h1>🐇 SSR vs SSG</h1>
<p>Next.js는 기본적으로 모든 페이지를 pre-rendering 한다. Next.js는 모든 페이지의 HTML를 미리 생성한다.</p>
<p>생성된 각각의 HTML은 해당 페이지에 필요한 최소한의 자바스크립트 코드와 연결된다. 페이지가 브라우저에 의해서 로드 된 뒤, 자바스크립트 코드가 실행되고 페이지를 interactive하게 만든다. Next.js에서는 이 개념을hydration이라고 한다.</p>
<p>Pre-rendering에는 두가지 형태가 있다. Static Generation과 Server-side Rendering(SSR). SSR은 익숙한데 Static Generation은 뭐지?</p>
<h2>Static Generation</h2>
<p>Static Generation, 즉 Static-site Generation(SSG)는 build time에 HTML을 생성한다. Next.js에서는 <code node="[object Object]">next build</code> 명령을 실행했을 때 페이지를 생성한다. 해당 페이지로 요청이 올 경우 이미 생성된 HTML을 반환한다. CDN에 캐싱하여 페이지를 빠르게 응답할 수 있다.</p>
<p>마케팅 페이지, 블로그 포스트 또는 포트폴리오, E-commerce의 제품 리스트, 도움 및 문서 페이지처럼 데이터의 실시간 변화가 적은 페이지를 SSG로 구성하면 빠른 응답이 가능하다.</p>
<h2>Server-side Rendering</h2>
<p>SSR은 페이지에 대한 요청이 있을 때 HTML을 생성한다. 따라서 실시간으로 데이터가 업데이트 되거나, 요청이 들어올 때마다 내용이 변경되는 페이지에 적합하다. 다만 SSG에 비해 속도가 느리기 때문에 반드시 필요할 때만 사용해야 한다.</p>
<h1>🐇 Next.js에서 SSG 적용</h1>
<p>Next.js와 React Query를 사용하여 간단하게 SSG를 구현해보자. 다음의 제품 리스트는 실시간으로 변화하는 데이터가 아니기 때문에 SSG로 pre-rendering하는 것이 적합하다.</p>
<p><img src="https://velog.velcdn.com/images/chchaeun/post/f081494e-ffac-4f85-858c-a6fc5a7edce0/image.png" alt=""/></p>
<p>기존의 화면에서 페이지 소스를 봤을 때, 찜한 상품, 장바구니 등의 코드는 있지만 제품 데이터에 관한 내용은 HTML에 포함되지 않았다. 따라서 현재 페이지가 요청됐을 때 자바스크립트를 통해 데이터를 불러오는 것을 알 수 있다.</p>
<p><img src="https://velog.velcdn.com/images/chchaeun/post/b0b25e17-9db8-4354-8dcc-b62f049fc5c1/image.png" alt=""/></p>
<h2>getStaticProps</h2>
<p><code node="[object Object]">getStaticProps</code> 라는 <code node="[object Object]">async</code> 함수를 <code node="[object Object]">export</code> 하면 build time에 호출된다. 이 함수는 <code node="[object Object]">List</code> 컴포넌트에서 사용될 데이터를 fetch하고 해당 페이지를 pre-rendering할 수 있도록 데이터를 넘겨준다. return 값에서 넘겨준 props가 List의 인자로 넘어간다.</p>
<p><code node="[object Object]">useInfiniteQuery</code> 와 함께 이 함수를 사용하려면 props의 형태를 쿼리의 데이터 반환 형태와 맞춰주어야 한다. 따라서 첫번째 페이지의 데이터를 담은 pages 배열과 pageParams를 넘겨주었다.</p>
<pre><div node="[object Object]" style="display:block;overflow-x:auto;padding:0.5em;color:#000;background:#f8f8ff"><code class="language-tsx" style="white-space:pre"><span style="color:#954121">const</span><span> List = </span><span class="hljs-function">(</span><span class="hljs-function" style="color:#00f">props</span><span class="hljs-function">) =&gt;</span><span> {
</span><span>  </span><span style="color:#408080;font-style:italic">// Render product lists...</span><span>
</span>};
<span></span><span style="color:#954121">export</span><span> </span><span style="color:#954121">async</span><span> </span><span class="hljs-function" style="color:#954121">function</span><span class="hljs-function"> </span><span class="hljs-function" style="color:#458;font-weight:bold">getStaticProps</span><span class="hljs-function">(</span><span class="hljs-function">) </span><span>{
</span><span>  </span><span style="color:#954121">const</span><span> data = </span><span style="color:#954121">await</span><span> fetchPhotos(</span><span style="color:#40a070">1</span><span>);
</span><span>  </span><span style="color:#954121">const</span><span> pages = [data];
</span><span>  </span><span style="color:#954121">return</span><span> {
</span><span>    </span><span class="hljs-attr">props</span><span>: {
</span>      pages,
<span>      </span><span class="hljs-attr">pageParams</span><span>: </span><span style="color:#40a070">1</span><span>,
</span>    },
<!-- -->  };
<!-- -->}</code></div></pre>
<p>형태에 맞게 interface를 작성해주었다.</p>
<pre><div node="[object Object]" style="display:block;overflow-x:auto;padding:0.5em;color:#000;background:#f8f8ff"><code class="language-tsx" style="white-space:pre"><span>interface IPage {
</span><span>  data: IPhoto</span><span style="color:#19469d">[]</span><span style="color:#408080;font-style:italic">;</span><span>
</span><span>  nextPage: number</span><span style="color:#408080;font-style:italic">;</span><span>
</span>}
<!-- -->interface IProps {
<span>  pageParams: number</span><span style="color:#19469d">[]</span><span style="color:#408080;font-style:italic">;</span><span>
</span><span>  pages: IPage</span><span style="color:#19469d">[]</span><span style="color:#408080;font-style:italic">;</span><span>
</span>}
<!-- -->
<span>const </span><span class="hljs-attr">List</span><span> = (props: IProps) =&gt; {
</span><span>  console.log(props)</span><span style="color:#408080;font-style:italic">;</span><span>
</span><span>}</span><span style="color:#408080;font-style:italic">;</span></code></div></pre>
<p>끝으로 <code node="[object Object]">useInfiniteQuery</code>의 option으로 initialData에 props를 넣으면 초기 데이터로 props가 들어가게 된다.</p>
<pre><div node="[object Object]" style="display:block;overflow-x:auto;padding:0.5em;color:#000;background:#f8f8ff"><code class="language-tsx" style="white-space:pre"><span>const { data, hasNextPage, fetchNextPage, isFetchingNextPage } =
</span>  useInfiniteQuery(
<span>    [</span><span style="color:#219161">&quot;photos&quot;</span><span>],
</span><span>    async ({ pageParam = </span><span style="color:#40a070">1</span><span> }) =&gt; {
</span><span>      return await fetchPhotos(</span><span style="color:#000080;font-weight:normal">pageParam</span><span>)</span><span style="color:#408080;font-style:italic">;</span><span>
</span>    },
<!-- -->    {
<!-- -->      initialData: props,
<span>      getNextPageParam: (</span><span style="color:#000080;font-weight:normal">lastPage</span><span>) =&gt; {
</span>        return lastPage.nextPage;
<!-- -->      },
<!-- -->    }
<span>  )</span><span style="color:#408080;font-style:italic">;</span></code></div></pre>
<p>이렇게 해준 뒤 페이지 소스를 보면 처음 불러오는 페이지 데이터가 HTML에 들어간 것을 볼 수 있다.</p>
<p><img src="https://velog.velcdn.com/images/chchaeun/post/a2711916-bb84-4359-b760-e575c33cea7a/image.png" alt=""/></p>
<h3>Build</h3>
<p><code node="[object Object]">npm run build</code> 를 실행하고 생성된 HTML 파일을 확인해보자. 데이터가 들어간 것을 확인할 수 있다.</p>
<p><img src="https://velog.velcdn.com/images/chchaeun/post/94dd40fd-7a63-461f-8f3a-745eac5b189e/image.png" alt=""/></p>
<p>개발할 때는 서버 상태가 변경됐을 때 바로 페이지에 반영이 되지만, 배포된 뒤에는 빌드 후 재배포하지 않는 이상 이 데이터는 변경되지 않는다.</p>
<h3>Incremental Static Generation(ISR)</h3>
<p>만약 배포를 하지 않고도 서버 상태가 갱신됐을 때 반영이 되도록 하고 싶으면 어떻게 해야 할까? 예를 들어 한 시간에 한 번 제품 리스트가 서버에서 변경되는데, 그 때마다 빌드&amp;배포를 하는 것이 번거로울 수 있다.</p>
<p>ISR 방식은 일정한 주기를 설정하면 해당 주기에 따라 페이지를 재생성하는 것이다. <code node="[object Object]">getStaticProps</code> 함수의 return값으로 revalidate 값을 추가한다. 다음 코드는 10초 단위로 페이지를 재생성하겠다는 의미이다.</p>
<pre><div node="[object Object]" style="display:block;overflow-x:auto;padding:0.5em;color:#000;background:#f8f8ff"><code class="language-tsx" style="white-space:pre"><span style="color:#000080;font-weight:normal">export async function getStaticProps</span><span>() {
</span><span></span><span style="color:#000080;font-weight:normal">  console</span><span>.log(&quot;Re-generating...&quot;);
</span>
<span></span><span style="color:#000080;font-weight:normal">  const data</span><span> = await fetchPhotos(1);
</span><span></span><span style="color:#000080;font-weight:normal">  const pages</span><span> = [data];
</span>
<span></span><span style="color:#000080;font-weight:normal">  return</span><span> {
</span><span></span><span style="color:#000080;font-weight:normal">    props</span><span>: {
</span><span></span><span style="color:#000080;font-weight:normal">      pages</span><span>,
</span><span></span><span style="color:#000080;font-weight:normal">      pageParams</span><span>: 1,
</span>    },
<span></span><span style="color:#000080;font-weight:normal">    revalidate</span><span>: 10,
</span>  };
<!-- -->}</code></div></pre>
<p>이렇게 설정하고 <code node="[object Object]">npm run build</code> 를 실행하면 터미널에 다음과 같이 나타난다.</p>
<p><img src="https://velog.velcdn.com/images/chchaeun/post/cc2412b2-9376-4b05-94de-e313e057be73/image.png" alt=""/></p>
<p><code node="[object Object]">npm start</code> 를 하면 개발 환경이 아닌 배포 환경에서 프로그램이 어떻게 동작하는지 확인할 수 있다.</p>
<p>처음 localhost:3000을 열었을 때 Re-generating이 콘솔에 찍힌다. 그 뒤에 바로 새로고침하면 아무런 변화가 일어나지 않지만 10초가 경과된 후 다시 페이지를 새로고침하면 Re-generating이 찍힌다. 설정해둔 주기를 기준으로 새로고침했을 때 페이지를 재생성할 것인지의 여부가 결정되는 것이다.</p>
<p><img src="https://velog.velcdn.com/images/chchaeun/post/9fe3a14c-d948-4c31-a5f6-85198f47fe9d/image.png" alt=""/></p>
<h2>getStaticPaths</h2>
<p>다이나믹 라우팅에서 SSG 방식을 적용하려면 어떻게 해야 할까? SSG 방식은 build time에 페이지를 생성하기 때문에 이 방식을 사용하려면 해당 페이지에 각각의 라우트로 접근했을 때 필요한 정보를 미리 가지고 있어야 한다.</p>
<p>라우트가 <code node="[object Object]">/id</code> 인 제품의 상세페이지에 대해 SSG 방식을 적용해볼 것이다.</p>
<p><img src="https://velog.velcdn.com/images/chchaeun/post/f4722420-ff4d-4dda-9555-c6c1ecbd903d/image.png" alt=""/></p>
<p><code node="[object Object]">getStaticProps</code> 를 사용해서 다음과 같이 아이디를 통해 제품의 상세 정보 데이터를 가져올 수 있다.</p>
<pre><div node="[object Object]" style="display:block;overflow-x:auto;padding:0.5em;color:#000;background:#f8f8ff"><code class="language-tsx" style="white-space:pre"><span style="color:#954121">interface</span><span> IParams {
</span><span>  </span><span class="hljs-attr">params</span><span>: {
</span><span>    </span><span class="hljs-attr">id</span><span>: </span><span style="color:#0086b3">string</span><span>;
</span>  };
<!-- -->}
<!-- -->
<span></span><span style="color:#954121">export</span><span> </span><span style="color:#954121">async</span><span> </span><span class="hljs-function" style="color:#954121">function</span><span class="hljs-function"> </span><span class="hljs-function" style="color:#458;font-weight:bold">getStaticProps</span><span class="hljs-function">(</span><span class="hljs-function" style="color:#00f">{ params }: { params: { id: </span><span class="hljs-function" style="color:#0086b3">string</span><span class="hljs-function" style="color:#00f"> } }</span><span class="hljs-function">) </span><span>{
</span><span>  </span><span style="color:#954121">const</span><span> data = </span><span style="color:#954121">await</span><span> fetchPhotoById(params.id);
</span><span>  </span><span style="color:#954121">return</span><span> { </span><span class="hljs-attr">props</span><span>: data };
</span>}</code></div></pre>
<p>이렇게 실행해보면 다음과 같은 에러가 뜨는 것을 볼 수 있다. <code node="[object Object]">getStaticPaths</code> 가 필요하다고 한다.</p>
<p><img src="https://velog.velcdn.com/images/chchaeun/post/f463c688-6505-4122-96bf-7981b797e70a/image.png" alt=""/></p>
<p>예를 들어 아이디가 ‘p1’인 제품의 상세페이지를 얻고 싶을 때 SSG 방식을 사용하려면 build time에 이미 p1에 대한 상세페이지가 생성되어 있어야 한다. 어떤 정적페이지를 생성할지 미리 결정하도록 하는 것이 <code node="[object Object]">getStaticPaths</code> 이다.</p>
<p>paths 배열에 params 값들을 넣어 리턴해주면 되는데, 예를 들어 아이디가 p1, p2, p3인 제품의 상세 페이지를 미리 생성하고 싶을 때 다음과 같이 작성하면 된다.</p>
<pre><div node="[object Object]" style="display:block;overflow-x:auto;padding:0.5em;color:#000;background:#f8f8ff"><code class="language-tsx" style="white-space:pre"><span>export async function getStaticPaths() {
</span>  return {
<!-- -->    paths: [
<span>      { params: { id: </span><span style="color:#219161">&quot;p1&quot;</span><span> } },
</span><span>      { params: { id: </span><span style="color:#219161">&quot;p2&quot;</span><span> } },
</span><span>      { params: { id: </span><span style="color:#219161">&quot;p3&quot;</span><span> } },
</span>    ],
<!-- -->  };
<!-- -->}</code></div></pre>
<h3>fallback</h3>
<p>미리 등록되지 않은 라우트에 접근하려고 했을 때 어떻게 처리할 것인지 정하는 옵션이다. <code node="[object Object]">true</code> , <code node="[object Object]">false</code> 혹은 <code node="[object Object]">blocking</code> 셋 중에 선택할 수 있다.</p>
<pre><div node="[object Object]" style="display:block;overflow-x:auto;padding:0.5em;color:#000;background:#f8f8ff"><code class="language-tsx" style="white-space:pre"><span style="color:#954121">export</span><span> </span><span style="color:#954121">async</span><span> </span><span class="hljs-function" style="color:#954121">function</span><span class="hljs-function"> </span><span class="hljs-function" style="color:#458;font-weight:bold">getStaticPaths</span><span class="hljs-function">(</span><span class="hljs-function">) </span><span>{
</span><span>  </span><span style="color:#954121">return</span><span> {
</span><span>    </span><span class="hljs-attr">paths</span><span>:[...],
</span><span>		</span><span class="hljs-attr">fallback</span><span>: </span><span style="color:#0086b3">boolean</span><span> | </span><span style="color:#219161">&#x27;blocking&#x27;</span><span>
</span>  };
<!-- -->}</code></div></pre>
<p>fallback이 <code node="[object Object]">false</code> 이면 미리 등록되지 않은 페이지에 접근했을 때 404 page가 나타나고, <code node="[object Object]">true</code> 이면 나타나지 않고 동적으로 처리한다. 만약 쇼핑몰과 같이 데이터가 매우 많아서 각각에 대한 모든 페이지를 pre-generating하기 힘들 때, fallback <code node="[object Object]">true</code> 를 이용하면 자주 접근되는 첫 페이지만 build time에 생성할 수 있다. fallback이 <code node="[object Object]">&#x27;blocking&#x27;</code> 일 땐</p>
<ul>
<li>
<p><code node="[object Object]">false</code></p>
<ul>
<li>미리 등록되지 않은 페이지에 접근했을 때 404 page가 나타난다.</li>
</ul>
</li>
<li>
<p><code node="[object Object]">true</code></p>
<ul>
<li>fallback 페이지를 띄우고, 서버에서 페이지를 생성한 뒤 사용자에게 보여준다.</li>
<li>다음에 같은 접근이 있을 때는 정적 페이지를 보여준다.</li>
<li><code node="[object Object]">useRouter</code> 를 통해 fallback 페이지를 설정할 수 있다.</li>
</ul>
<pre><div node="[object Object]" style="display:block;overflow-x:auto;padding:0.5em;color:#000;background:#f8f8ff"><code class="language-tsx" style="white-space:pre"><span style="color:#954121">const</span><span> router = useRouter();
</span>
<span></span><span style="color:#954121">if</span><span> (router.isFallback) {
</span><span>  </span><span style="color:#954121">return</span><span> &lt;</span><span style="color:#954121">div</span><span>&gt;Loading...&lt;/</span><span style="color:#954121">div</span><span>&gt;;
</span>}</code></div></pre>
</li>
<li>
<p><code node="[object Object]">&#x27;blocking&#x27;</code></p>
<ul>
<li>서버 사이드 렌더링한 정적 페이지를 보여준다.</li>
<li>해당 path를 등록해두었다가 다음에 같은 접근이 있을 때 정적 페이지를 보여준다.</li>
</ul>
</li>
</ul></div><section></section></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"postData":{"id":"next.js","title":"next.js","category":"test","thumbnail":"https://images.unsplash.com/photo-1514888286974-6c03e2ca1dba?ixlib=rb-1.2.1\u0026ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8\u0026auto=format\u0026fit=crop\u0026w=1443\u0026q=80","tags":"Next.js, SSR, SSG, frontend, react","date":"2022-07-12 10:00","preview":"🐇 SSR vs SSG\n\nNext.js는 기본적으로 모든 페이지를 pre-rendering 한다. Next.js는 모든 페이지의 HTML를 미리 생성한다.\n\n생성된 각각의 HTML은 해당 페이지에 필요한 최소한의 자바스크립트 코드와 연결된다. 페이지"},"detail":"\n# 🐇 SSR vs SSG\n\nNext.js는 기본적으로 모든 페이지를 pre-rendering 한다. Next.js는 모든 페이지의 HTML를 미리 생성한다.\n\n생성된 각각의 HTML은 해당 페이지에 필요한 최소한의 자바스크립트 코드와 연결된다. 페이지가 브라우저에 의해서 로드 된 뒤, 자바스크립트 코드가 실행되고 페이지를 interactive하게 만든다. Next.js에서는 이 개념을hydration이라고 한다.\n\nPre-rendering에는 두가지 형태가 있다. Static Generation과 Server-side Rendering(SSR). SSR은 익숙한데 Static Generation은 뭐지?\n\n## Static Generation\n\nStatic Generation, 즉 Static-site Generation(SSG)는 build time에 HTML을 생성한다. Next.js에서는 `next build` 명령을 실행했을 때 페이지를 생성한다. 해당 페이지로 요청이 올 경우 이미 생성된 HTML을 반환한다. CDN에 캐싱하여 페이지를 빠르게 응답할 수 있다.\n\n마케팅 페이지, 블로그 포스트 또는 포트폴리오, E-commerce의 제품 리스트, 도움 및 문서 페이지처럼 데이터의 실시간 변화가 적은 페이지를 SSG로 구성하면 빠른 응답이 가능하다.\n\n## Server-side Rendering\n\nSSR은 페이지에 대한 요청이 있을 때 HTML을 생성한다. 따라서 실시간으로 데이터가 업데이트 되거나, 요청이 들어올 때마다 내용이 변경되는 페이지에 적합하다. 다만 SSG에 비해 속도가 느리기 때문에 반드시 필요할 때만 사용해야 한다.\n\n# 🐇 Next.js에서 SSG 적용\n\nNext.js와 React Query를 사용하여 간단하게 SSG를 구현해보자. 다음의 제품 리스트는 실시간으로 변화하는 데이터가 아니기 때문에 SSG로 pre-rendering하는 것이 적합하다.\n\n![](https://velog.velcdn.com/images/chchaeun/post/f081494e-ffac-4f85-858c-a6fc5a7edce0/image.png)\n\n기존의 화면에서 페이지 소스를 봤을 때, 찜한 상품, 장바구니 등의 코드는 있지만 제품 데이터에 관한 내용은 HTML에 포함되지 않았다. 따라서 현재 페이지가 요청됐을 때 자바스크립트를 통해 데이터를 불러오는 것을 알 수 있다.\n\n![](https://velog.velcdn.com/images/chchaeun/post/b0b25e17-9db8-4354-8dcc-b62f049fc5c1/image.png)\n\n## getStaticProps\n\n`getStaticProps` 라는 `async` 함수를 `export` 하면 build time에 호출된다. 이 함수는 `List` 컴포넌트에서 사용될 데이터를 fetch하고 해당 페이지를 pre-rendering할 수 있도록 데이터를 넘겨준다. return 값에서 넘겨준 props가 List의 인자로 넘어간다.\n\n`useInfiniteQuery` 와 함께 이 함수를 사용하려면 props의 형태를 쿼리의 데이터 반환 형태와 맞춰주어야 한다. 따라서 첫번째 페이지의 데이터를 담은 pages 배열과 pageParams를 넘겨주었다.\n\n```tsx\nconst List = (props) =\u003e {\n  // Render product lists...\n};\nexport async function getStaticProps() {\n  const data = await fetchPhotos(1);\n  const pages = [data];\n  return {\n    props: {\n      pages,\n      pageParams: 1,\n    },\n  };\n}\n```\n\n형태에 맞게 interface를 작성해주었다.\n\n```tsx\ninterface IPage {\n  data: IPhoto[];\n  nextPage: number;\n}\ninterface IProps {\n  pageParams: number[];\n  pages: IPage[];\n}\n\nconst List = (props: IProps) =\u003e {\n  console.log(props);\n};\n```\n\n끝으로 `useInfiniteQuery`의 option으로 initialData에 props를 넣으면 초기 데이터로 props가 들어가게 된다.\n\n```tsx\nconst { data, hasNextPage, fetchNextPage, isFetchingNextPage } =\n  useInfiniteQuery(\n    [\"photos\"],\n    async ({ pageParam = 1 }) =\u003e {\n      return await fetchPhotos(pageParam);\n    },\n    {\n      initialData: props,\n      getNextPageParam: (lastPage) =\u003e {\n        return lastPage.nextPage;\n      },\n    }\n  );\n```\n\n이렇게 해준 뒤 페이지 소스를 보면 처음 불러오는 페이지 데이터가 HTML에 들어간 것을 볼 수 있다.\n\n![](https://velog.velcdn.com/images/chchaeun/post/a2711916-bb84-4359-b760-e575c33cea7a/image.png)\n\n### Build\n\n`npm run build` 를 실행하고 생성된 HTML 파일을 확인해보자. 데이터가 들어간 것을 확인할 수 있다.\n\n![](https://velog.velcdn.com/images/chchaeun/post/94dd40fd-7a63-461f-8f3a-745eac5b189e/image.png)\n\n개발할 때는 서버 상태가 변경됐을 때 바로 페이지에 반영이 되지만, 배포된 뒤에는 빌드 후 재배포하지 않는 이상 이 데이터는 변경되지 않는다.\n\n### Incremental Static Generation(ISR)\n\n만약 배포를 하지 않고도 서버 상태가 갱신됐을 때 반영이 되도록 하고 싶으면 어떻게 해야 할까? 예를 들어 한 시간에 한 번 제품 리스트가 서버에서 변경되는데, 그 때마다 빌드\u0026배포를 하는 것이 번거로울 수 있다.\n\nISR 방식은 일정한 주기를 설정하면 해당 주기에 따라 페이지를 재생성하는 것이다. `getStaticProps` 함수의 return값으로 revalidate 값을 추가한다. 다음 코드는 10초 단위로 페이지를 재생성하겠다는 의미이다.\n\n```tsx\nexport async function getStaticProps() {\n  console.log(\"Re-generating...\");\n\n  const data = await fetchPhotos(1);\n  const pages = [data];\n\n  return {\n    props: {\n      pages,\n      pageParams: 1,\n    },\n    revalidate: 10,\n  };\n}\n```\n\n이렇게 설정하고 `npm run build` 를 실행하면 터미널에 다음과 같이 나타난다.\n\n![](https://velog.velcdn.com/images/chchaeun/post/cc2412b2-9376-4b05-94de-e313e057be73/image.png)\n\n`npm start` 를 하면 개발 환경이 아닌 배포 환경에서 프로그램이 어떻게 동작하는지 확인할 수 있다.\n\n처음 localhost:3000을 열었을 때 Re-generating이 콘솔에 찍힌다. 그 뒤에 바로 새로고침하면 아무런 변화가 일어나지 않지만 10초가 경과된 후 다시 페이지를 새로고침하면 Re-generating이 찍힌다. 설정해둔 주기를 기준으로 새로고침했을 때 페이지를 재생성할 것인지의 여부가 결정되는 것이다.\n\n![](https://velog.velcdn.com/images/chchaeun/post/9fe3a14c-d948-4c31-a5f6-85198f47fe9d/image.png)\n\n## getStaticPaths\n\n다이나믹 라우팅에서 SSG 방식을 적용하려면 어떻게 해야 할까? SSG 방식은 build time에 페이지를 생성하기 때문에 이 방식을 사용하려면 해당 페이지에 각각의 라우트로 접근했을 때 필요한 정보를 미리 가지고 있어야 한다.\n\n라우트가 `/id` 인 제품의 상세페이지에 대해 SSG 방식을 적용해볼 것이다.\n\n![](https://velog.velcdn.com/images/chchaeun/post/f4722420-ff4d-4dda-9555-c6c1ecbd903d/image.png)\n\n`getStaticProps` 를 사용해서 다음과 같이 아이디를 통해 제품의 상세 정보 데이터를 가져올 수 있다.\n\n```tsx\ninterface IParams {\n  params: {\n    id: string;\n  };\n}\n\nexport async function getStaticProps({ params }: { params: { id: string } }) {\n  const data = await fetchPhotoById(params.id);\n  return { props: data };\n}\n```\n\n이렇게 실행해보면 다음과 같은 에러가 뜨는 것을 볼 수 있다. `getStaticPaths` 가 필요하다고 한다.\n\n![](https://velog.velcdn.com/images/chchaeun/post/f463c688-6505-4122-96bf-7981b797e70a/image.png)\n\n예를 들어 아이디가 ‘p1’인 제품의 상세페이지를 얻고 싶을 때 SSG 방식을 사용하려면 build time에 이미 p1에 대한 상세페이지가 생성되어 있어야 한다. 어떤 정적페이지를 생성할지 미리 결정하도록 하는 것이 `getStaticPaths` 이다.\n\npaths 배열에 params 값들을 넣어 리턴해주면 되는데, 예를 들어 아이디가 p1, p2, p3인 제품의 상세 페이지를 미리 생성하고 싶을 때 다음과 같이 작성하면 된다.\n\n```tsx\nexport async function getStaticPaths() {\n  return {\n    paths: [\n      { params: { id: \"p1\" } },\n      { params: { id: \"p2\" } },\n      { params: { id: \"p3\" } },\n    ],\n  };\n}\n```\n\n### fallback\n\n미리 등록되지 않은 라우트에 접근하려고 했을 때 어떻게 처리할 것인지 정하는 옵션이다. `true` , `false` 혹은 `blocking` 셋 중에 선택할 수 있다.\n\n```tsx\nexport async function getStaticPaths() {\n  return {\n    paths:[...],\n\t\tfallback: boolean | 'blocking'\n  };\n}\n```\n\nfallback이 `false` 이면 미리 등록되지 않은 페이지에 접근했을 때 404 page가 나타나고, `true` 이면 나타나지 않고 동적으로 처리한다. 만약 쇼핑몰과 같이 데이터가 매우 많아서 각각에 대한 모든 페이지를 pre-generating하기 힘들 때, fallback `true` 를 이용하면 자주 접근되는 첫 페이지만 build time에 생성할 수 있다. fallback이 `'blocking'` 일 땐\n\n- `false`\n  - 미리 등록되지 않은 페이지에 접근했을 때 404 page가 나타난다.\n- `true`\n\n  - fallback 페이지를 띄우고, 서버에서 페이지를 생성한 뒤 사용자에게 보여준다.\n  - 다음에 같은 접근이 있을 때는 정적 페이지를 보여준다.\n  - `useRouter` 를 통해 fallback 페이지를 설정할 수 있다.\n\n  ```tsx\n  const router = useRouter();\n\n  if (router.isFallback) {\n    return \u003cdiv\u003eLoading...\u003c/div\u003e;\n  }\n  ```\n\n- `'blocking'`\n  - 서버 사이드 렌더링한 정적 페이지를 보여준다.\n  - 해당 path를 등록해두었다가 다음에 같은 접근이 있을 때 정적 페이지를 보여준다.\n"},"__N_SSG":true},"page":"/[id]","query":{"id":"next.js"},"buildId":"OL6IxY-eToHWPnPapaxI-","assetPrefix":"/blog","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>